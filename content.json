{"pages":[{"title":"所有标签","date":"2021-11-12T03:24:03.721Z","path":"tags/index.html","text":""},{"title":"所有分类","date":"2021-11-12T03:24:03.721Z","path":"categories/index.html","text":""},{"title":"","date":"2021-11-12T03:24:03.721Z","path":"about/index.html","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2021-11-12T03:24:03.721Z","path":"friends/index.html","text":"请看，这些是大佬 欢迎大家留下友链~~添加需要以下这些信息 12345- title: 乱序 # 名称avatar: https://cdn.jsdelivr.net/gh/luanluanxu/assets@master/images/avatar.jpg # 头像urlurl: https://luanxu.me/ # 链接keywords: # 关键词 可选description: # 描述 可选"}],"posts":[{"title":"SPA重新构建部署如何刷新缓存","date":"2021-10-08T01:55:09.000Z","path":"posts/3130060804/","text":"问题单页面应用在重新部署更新时，此时正在浏览网页，并且已经在网页内的用户，始终会使用老的js与css文件，一直在使用已经缓存了的静态资源。 分析在HTTP协议中，响应头有 expires 或 Cache-Control:max-age=XXX， 前端才缓存。但在浏览器中，默认会对html,js,css,字体,音视频等静态文件、以及重定向进行缓存，如果在HEAD标签中指定： 12345&lt;HEAD&gt; &lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt; &lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; &lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&gt;&lt;/HEAD&gt; 浏览器不会缓存html，但是还是会对重定向缓存并且这种方式并不规范，可能有的浏览器不支持。 解决方案 对hash过的静态文件还是采用默认方式，客户端会缓存。 对html文件，返回时增加头：Cache-Control，必须每次来服务端校验，根据 ETAG 返回200或者304 12345678# 前端html文件 location / &#123; add_header Cache-Control &#x27;no-cache, must-revalidate, proxy-revalidate, max-age=0&#x27;; root /var/www/example/dist/; index index.html index.htm; try_files $uri /index.html; &#125; 参考资料 ETAG - MDN Cache-Control - RFC2616","tags":[{"name":"SPA","slug":"SPA","permalink":"https://luanxu.me/tags/SPA/"},{"name":"前端缓存","slug":"前端缓存","permalink":"https://luanxu.me/tags/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"},{"name":"前端优化","slug":"前端优化","permalink":"https://luanxu.me/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"}]},{"title":"Go IOC 依赖注入 Dig|Wire|Inject","date":"2021-09-09T01:28:30.000Z","path":"posts/2454711668/","text":"什么是控制反转(IOC)?Inversion of Control (IoC) 是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup） 用大白话说就是你想实例化一个对象，但是这个对象又层层依赖其他对象，原本你需要由自己一个个去处理好这些对象间的依赖关系，现在可以解放双手交给IOC框架自己去处理了，不需要自己每次都去写实例化部分的代码了 无IOC的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;fmt&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)type MysqlConfig struct &#123; Dsn string MaxIdle int MaxOpen int MaxLife int&#125;type DataSourceType struct &#123; DB *gorm.DB&#125;var DataSource *DataSourceTypefunc main() &#123; // no ioc mysqlConfig := &amp;MysqlConfig&#123; Dsn: &quot;dsn&quot;, &#125; gormDb, err := gorm.Open(mysql.New(mysql.Config&#123; DSN: mysqlConfig.Dsn, &#125;), &amp;gorm.Config&#123;SkipDefaultTransaction: true&#125;) if err != nil &#123; fmt.Errorf(&quot;Db init error : %s&quot;, err.Error()) &#125; DataSource = &amp;DataSourceType&#123; DB: gormDb, &#125; var userCount int64 if err := DataSource.DB.Table(&quot;user&quot;).Count(&amp;userCount).Error; err != nil &#123; fmt.Println(&quot;User count error&quot;) &#125; fmt.Printf(&quot;no ioc User count: %v&quot;, userCount)&#125; 运行结果12$ go run ioc.gono ioc User count: 12 Uber-go/DigUber-go/dig 是一个基于反射的 Go 依赖注入工具包。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot; &quot;go.uber.org/dig&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)type MysqlConfig struct &#123; Dsn string MaxIdle int MaxOpen int MaxLife int&#125;type DataSourceType struct &#123; DB *gorm.DB&#125;var DataSource *DataSourceTypefunc main() &#123; mysqlConfig := &amp;MysqlConfig&#123; Dsn: &quot;dsn&quot;, &#125; // uber-go/dig Constructors for different types are added to the container by using the Provide method. c := dig.New() if err := c.Provide(func() *MysqlConfig &#123; return mysqlConfig &#125;); err != nil &#123; fmt.Printf(&quot;Provide error : %s&quot;, err) &#125; if err := c.Provide(func(mconfig *MysqlConfig) (*gorm.DB, error) &#123; return gorm.Open(mysql.New(mysql.Config&#123; DSN: mconfig.Dsn, &#125;), &amp;gorm.Config&#123;SkipDefaultTransaction: true&#125;) &#125;); err != nil &#123; fmt.Printf(&quot;Provide error : %s&quot;, err) &#125; // using *gorm.DB from container if err := c.Invoke(func(db *gorm.DB) &#123; DataSource = &amp;DataSourceType&#123; DB: db, &#125; &#125;); err != nil &#123; fmt.Printf(&quot;Provide error : %s&quot;, err) &#125; var userCount int64 if err := DataSource.DB.Table(&quot;user&quot;).Count(&amp;userCount).Error; err != nil &#123; fmt.Println(&quot;User count error&quot;) &#125; fmt.Printf(&quot;uber-go/dig User count: %v&quot;, userCount)&#125; 运行结果12$ go run ioc.gouber-go/dig User count: 12 以下内容正在施工中google/wirefacebook-go/inject参考资料 uber-go/dig google/wire facebook-go/inject","tags":[{"name":"IOC","slug":"IOC","permalink":"https://luanxu.me/tags/IOC/"},{"name":"Di","slug":"Di","permalink":"https://luanxu.me/tags/Di/"},{"name":"Dig","slug":"Dig","permalink":"https://luanxu.me/tags/Dig/"},{"name":"Wire","slug":"Wire","permalink":"https://luanxu.me/tags/Wire/"},{"name":"Inject","slug":"Inject","permalink":"https://luanxu.me/tags/Inject/"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"后端","slug":"技术/后端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/"},{"name":"Golang","slug":"技术/后端/Golang","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Golang/"}]},{"title":"让前端自定义查询条件和分页","date":"2021-08-31T13:52:53.000Z","path":"posts/3693711526/","text":"需求分析作为一名后端在做Web后端业务开发时，都应该遵循以下规则 降低代码耦合度 尽量避免代码冗余 在使用RESTFUL API风格开发时，几乎所有方法为 GET 的 列表或详情 接口 都不可避免的需要用到 分页、查询筛选条件、自定义排序 的功能 假如我们为每个接口去分别开发以上三种功能，将会耗费大量时间 问题分析 相同的功能，代码相似度高 当后端开发完成后，需要修改查询筛选条件时，前端无法及时反馈，需要等后端发布测试 解决方法很多后端都会将 查询筛选条件 、 自定义排序 做成参数查询 但是 查询筛选条件 则要一个个写接收请求参数并且去调用 where/orwhere/like/where in… 等方法去挨个处理 那要如何把选择权和控制权交给前端同事呢？我们可以给所有接口获取列表的封装个方法 在这里使用的是 Gin+Gorm 的例子，其他框架也可以使用类似操作解决这样的问题 自定义分页1234567891011121314151617func Paging(c *gin.Context, db *gorm.DB) (db *gorm.DB, err error) &#123; limitStr := c.Request.FormValue(&quot;limit&quot;) pageStr := c.Request.FormValue(&quot;page&quot;) if limitStr == &quot;&quot; || pageStr == &quot;&quot; &#123; return db, nil &#125; limit, err := strconv.Atoi(limitStr) if err != nil &#123; return db, nil &#125; page, err := strconv.Atoi(pageStr) if err != nil &#123; return db, nil &#125; db = db.Offset((page - 1) * limit).Limit(limit) return db, nil&#125; 自定义排序12345678910111213func Sort(c *gin.Context, db *gorm.DB) *gorm.DB &#123; orderBy := c.Request.FormValue(&quot;order_by&quot;) if orderBy == &quot;&quot; &#123; return db &#125; order := c.Request.FormValue(&quot;order&quot;) if order != &quot;&quot; &#123; db = db.Order(orderBy + &quot; &quot; + order) &#125; else &#123; db = db.Order(orderBy + &quot; DESC&quot;) &#125; return db&#125; 自定义查询筛选条件分页和自定义排序功能就不做解释了，做过web后端基本都了解了 按照field_查询操作符_字段名的格式前端请求的query参数中提取并添加查询条件 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 按照field_查询操作符_字段名的格式前端请求的query参数中提取并添加查询条件func ConditionSupport(c *gin.Context, db *gorm.DB) (*gorm.DB, error) &#123; query, err := url.ParseQuery(c.Request.URL.RawQuery) if err != nil &#123; return nil, errors.New(&quot;请求参数不正确，请联系管理员进行处理&quot;) &#125; // 找出所有带有field开头的，并且字符串长度大于9的query参数 for name, value := range query &#123; if !strings.HasPrfix(name, &quot;field&quot;) || len(name) &lt;= 9 &#123; return db,nil &#125; // 给字段添加反引号，避免关键字等 fieldName := &quot;`&quot; + name[9:] + &quot;`&quot; // 联表字段处理 例如 `user`.`id` fieldName = strings.Replace(fieldName,&quot;.&quot;,&quot;`.`&quot;,-1) //取出操作符 opt := name[6:8] switch opt &#123; case &quot;eq&quot;: if len(value) == 1 &#123; db = db.Where(fieldName+&quot;=?&quot;, value[0]) &#125; else &#123; db = db.Where(fieldName+&quot; IN (?)&quot;, value) &#125; case &quot;ne&quot;: db = db.Where(fieldName+&quot;&lt;&gt;?&quot;, value[0]) case &quot;lt&quot;: db = db.Where(fieldName+&quot;&lt;?&quot;, value[0]) case &quot;le&quot;: db = db.Where(fieldName+&quot;&lt;=?&quot;, value[0]) case &quot;gt&quot;: db = db.Where(fieldName+&quot;&gt;?&quot;, value[0]) case &quot;ge&quot;: db = db.Where(fieldName+&quot;&gt;=?&quot;, value[0]) case &quot;lk&quot;: db = db.Where(fieldName+&quot; LIKE ?&quot;, &quot;%&quot;+value[0]+&quot;%&quot;) case &quot;re&quot;: db = db.Where(fieldName+&quot; REGEXP ?&quot;, value[0]) default: return nil, errors.New(&quot;不支持的条件查询操作&quot;) &#125; &#125; return db, nil&#125; 结合三种方法一起使用123456789101112131415161718192021222324func Find(c *gin.Context, db *gorm.DB, result *interface&#123;&#125;) (int64, error) &#123; var count int64 err := c.Request.ParseForm() if err != nil &#123; return 0, errors.New(&quot;参数不正确&quot;) &#125; // 添加自定义查询条件 db, err = ConditionSupport(c, db) if err != nil &#123; return 0, errors.New(&quot;查询条件有误&quot;) &#125; // 添加分页支持 db, err = Paging(c, db) if err != nil &#123; return 0, errors.New(&quot;分页参数不正确&quot;) &#125; err = db.Count(&amp;count).Error if err != nil &#123; return 0, errors.New(&quot;数据库记录统计失败，请稍后再试&quot;) &#125; // 添加自定义排序 err = Sort(c, db).Find(result).Error return count, errors.New(&quot;数据库记录查询失败，请稍后再试&quot;)&#125; 最后我们只需要给每个需要 分页、查询筛选条件、自定义排序 的地方使用Find函数便可以将操作权交给前端了","tags":[{"name":"Gorm","slug":"Gorm","permalink":"https://luanxu.me/tags/Gorm/"},{"name":"Gin","slug":"Gin","permalink":"https://luanxu.me/tags/Gin/"},{"name":"Full Stack","slug":"Full-Stack","permalink":"https://luanxu.me/tags/Full-Stack/"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"后端","slug":"技术/后端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/"},{"name":"Golang","slug":"技术/后端/Golang","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Golang/"}]},{"title":"JSON.stringify中的replacer","date":"2021-08-25T05:00:32.000Z","path":"posts/1232104679/","text":"需求分析当我们在遇到需要深拷贝一个对象所有属性的时候会想把关联的数据排除在外，例如这样的一个对象关联的send_by_user 当你的需求是修改这个庞大对象并且整体提交更新的时候会发现以下问题 这个多余关联的对象不需要提交 发出请求的数据量变大 123456789101112131415161718192021222324252627282930&#123; &quot;id&quot;: 41, &quot;title&quot;: &quot;消息标题&quot;, &quot;content&quot;: &quot;消息内容&quot;, &quot;send_by&quot;: 2, &quot;send_by_user&quot;: &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;admin&quot;, &quot;telephone&quot;: &quot;&quot;, &quot;email&quot;: &quot;10000@qq.com&quot;, &quot;department_id&quot;: 1, &quot;department_name&quot;: &quot;&quot;, &quot;department&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;产品设计部&quot;, &quot;status&quot;: 1, &quot;created_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot;, &quot;updated_at&quot;: &quot;2021-08-21T16:12:05+08:00&quot; &#125;, &quot;status&quot;: 1, &quot;info&quot;: &quot;&quot;, &quot;created_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot;, &quot;updated_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot; &#125;, &quot;send_to&quot;: 2, &quot;status&quot;: 2, &quot;created_at&quot;: &quot;2021-08-21T16:55:53+08:00&quot;, &quot;deleted_at&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;updated_at&quot;: &quot;2021-08-25T10:14:57+08:00&quot;&#125; 解决方法控制 JSON.stringify 序列化层级JSON.stringify(value[, replacer [, space]]) 使用JSON.stringify时传入第二个参数 replacer 可选如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。 那我们只需要通过replacer传入函数过滤掉属性值是Object即可 1234567891011JSON.stringify(message,(k,v) =&gt; &#123; // k,v分别代表传入对象的属性名和属性值 // 判断k是因为replace会传入一个 传入参数对象 的值,但是没有k, 我们直接返回即可 if(!k) &#123; return v &#125; if(typeof v === &quot;object&quot;) &#123; return null &#125; return v&#125;) 参考资料 MDN Web Docs","tags":[],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"技术/后端","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/"},{"name":"Golang","slug":"技术/后端/Golang","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Golang/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"SPA","slug":"SPA","permalink":"https://luanxu.me/tags/SPA/"},{"name":"前端缓存","slug":"前端缓存","permalink":"https://luanxu.me/tags/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"},{"name":"前端优化","slug":"前端优化","permalink":"https://luanxu.me/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"IOC","slug":"IOC","permalink":"https://luanxu.me/tags/IOC/"},{"name":"Di","slug":"Di","permalink":"https://luanxu.me/tags/Di/"},{"name":"Dig","slug":"Dig","permalink":"https://luanxu.me/tags/Dig/"},{"name":"Wire","slug":"Wire","permalink":"https://luanxu.me/tags/Wire/"},{"name":"Inject","slug":"Inject","permalink":"https://luanxu.me/tags/Inject/"},{"name":"Gorm","slug":"Gorm","permalink":"https://luanxu.me/tags/Gorm/"},{"name":"Gin","slug":"Gin","permalink":"https://luanxu.me/tags/Gin/"},{"name":"Full Stack","slug":"Full-Stack","permalink":"https://luanxu.me/tags/Full-Stack/"}]}