{"pages":[{"title":"所有标签","date":"2021-08-31T15:39:19.963Z","path":"tags/index.html","text":""},{"title":"所有分类","date":"2021-08-31T15:39:19.963Z","path":"categories/index.html","text":""},{"title":"","date":"2021-08-31T15:39:19.963Z","path":"about/index.html","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2021-08-31T15:39:19.963Z","path":"friends/index.html","text":"请看，这些是大佬 欢迎大家留下友链~~添加需要以下这些信息 12345- title: ControlNet # 名称avatar: https://controlnet.space/images/logo.png # 头像url: https://controlnet.space/ # 链接keywords: # 关键词 可选description: # 描述 可选"}],"posts":[{"title":"让前端自定义查询条件和分页","date":"2021-08-31T13:52:53.000Z","path":"posts/45583/","text":"需求分析作为一名后端在做Web后端业务开发时，都应该遵循以下规则 降低代码耦合度 尽量避免代码冗余 在使用RESTFUL API风格开发时，几乎所有方法为 GET 的 列表或详情 接口 都不可避免的需要用到 分页、查询筛选条件、自定义排序 的功能 假如我们为每个接口去分别开发以上三种功能，将会耗费大量时间 问题分析 相同的功能，代码相似度高 当后端开发完成后，需要修改查询筛选条件时，前端无法及时反馈，需要等后端发布测试 解决方法很多后端都会将 查询筛选条件 、 自定义排序 做成参数查询 但是 查询筛选条件 则要一个个写接收请求参数并且去调用 where/orwhere/like/where in… 等方法去挨个处理 那要如何把选择权和控制权交给前端同事呢？我们可以给所有接口获取列表的封装个方法 在这里使用的是 Gin+Gorm 的例子，其他框架也可以使用类似操作解决这样的问题 自定义分页1234567891011121314151617func Paging(c *gin.Context, db *gorm.DB) (db *gorm.DB, err error) &#123; limitStr := c.Request.FormValue(&quot;limit&quot;) pageStr := c.Request.FormValue(&quot;page&quot;) if limitStr == &quot;&quot; || pageStr == &quot;&quot; &#123; return db, nil &#125; limit, err := strconv.Atoi(limitStr) if err != nil &#123; return db, nil &#125; page, err := strconv.Atoi(pageStr) if err != nil &#123; return db, nil &#125; db = db.Offset((page - 1) * limit).Limit(limit) return db, nil&#125; 自定义排序12345678910111213func Sort(c *gin.Context, db *gorm.DB) *gorm.DB &#123; orderBy := c.Request.FormValue(&quot;order_by&quot;) if orderBy == &quot;&quot; &#123; return db &#125; order := c.Request.FormValue(&quot;order&quot;) if order != &quot;&quot; &#123; db = db.Order(orderBy + &quot; &quot; + order) &#125; else &#123; db = db.Order(orderBy + &quot; DESC&quot;) &#125; return db&#125; 自定义查询筛选条件分页和自定义排序功能就不做解释了，做过web后端基本都了解了 按照field_查询操作符_字段名的格式前端请求的query参数中提取并添加查询条件 123456789101112131415161718192021222324252627282930313233343536373839// 按照field_查询操作符_字段名的格式前端请求的query参数中提取并添加查询条件func ConditionSupport(c *gin.Context, db *gorm.DB) (*gorm.DB, error) &#123; query, err := url.ParseQuery(c.Request.URL.RawQuery) if err != nil &#123; return nil, errors.New(&quot;请求参数不正确，请联系管理员进行处理&quot;) &#125; // 找出所有带有field开头的，并且字符串长度大于9的query参数 for name, value := range query &#123; if !strings.HasPrfix(name, &quot;field&quot;) || len(name) &lt;= 9 &#123; return db,nil &#125; fieldName := name[9:] //取出操作符 opt := name[6:8] switch opt &#123; case &quot;eq&quot;: if len(value) == 1 &#123; db = db.Where(fieldName+&quot;=?&quot;, value[0]) &#125; else &#123; db = db.Where(fieldName+&quot; IN (?)&quot;, value) &#125; case &quot;ne&quot;: db = db.Where(fieldName+&quot;&lt;&gt;?&quot;, value[0]) case &quot;lt&quot;: db = db.Where(fieldName+&quot;&lt;?&quot;, value[0]) case &quot;le&quot;: db = db.Where(fieldName+&quot;&lt;=?&quot;, value[0]) case &quot;gt&quot;: db = db.Where(fieldName+&quot;&gt;?&quot;, value[0]) case &quot;ge&quot;: db = db.Where(fieldName+&quot;&gt;=?&quot;, value[0]) case &quot;lk&quot;: db = db.Where(fieldName+&quot; LIKE ?&quot;, &quot;%&quot;+value[0]+&quot;%&quot;) default: return nil, errors.New(&quot;不支持的条件查询操作&quot;) &#125; &#125; return db, nil&#125; 结合三种方法一起使用123456789101112131415161718192021222324func Find(c *gin.Context, db *gorm.DB, result *interface&#123;&#125;) (int64, error) &#123; var count int64 err := c.Request.ParseForm() if err != nil &#123; return 0, errors.New(&quot;参数不正确&quot;) &#125; // 添加自定义查询条件 db, err = ConditionSupport(c, db) if err != nil &#123; return 0, errors.New(&quot;查询条件有误&quot;) &#125; // 添加分页支持 db, err = Paging(c, db) if err != nil &#123; return 0, errors.New(&quot;分页参数不正确&quot;) &#125; err = db.Count(&amp;count).Error if err != nil &#123; return 0, errors.New(&quot;数据库记录统计失败，请稍后再试&quot;) &#125; // 添加自定义排序 err = Sort(c, db).Find(result).Error return count, errors.New(&quot;数据库记录查询失败，请稍后再试&quot;)&#125; 最后我们只需要给每个需要 分页、查询筛选条件、自定义排序 的地方使用Find函数便可以将操作权交给前端了","tags":[{"name":"Gorm","slug":"Gorm","permalink":"https://luanxu.me/tags/Gorm/"},{"name":"Gin","slug":"Gin","permalink":"https://luanxu.me/tags/Gin/"},{"name":"Full Stack","slug":"Full-Stack","permalink":"https://luanxu.me/tags/Full-Stack/"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/Golang/"}]},{"title":"JSON.stringify中的replacer","date":"2021-08-25T05:00:32.000Z","path":"posts/29099/","text":"需求分析当我们在遇到需要深拷贝一个对象所有属性的时候会想把关联的数据排除在外，例如这样的一个对象关联的send_by_user 123456789101112131415161718192021222324252627282930&#123; &quot;id&quot;: 41, &quot;title&quot;: &quot;消息标题&quot;, &quot;content&quot;: &quot;消息内容&quot;, &quot;send_by&quot;: 2, &quot;send_by_user&quot;: &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;guoguixin&quot;, &quot;telephone&quot;: &quot;&quot;, &quot;email&quot;: &quot;10000@qq.com&quot;, &quot;department_id&quot;: 1, &quot;department_name&quot;: &quot;&quot;, &quot;department&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;产品设计部&quot;, &quot;status&quot;: 1, &quot;created_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot;, &quot;updated_at&quot;: &quot;2021-08-21T16:12:05+08:00&quot; &#125;, &quot;status&quot;: 1, &quot;info&quot;: &quot;&quot;, &quot;created_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot;, &quot;updated_at&quot;: &quot;1970-01-01T08:00:00+08:00&quot; &#125;, &quot;send_to&quot;: 2, &quot;status&quot;: 2, &quot;created_at&quot;: &quot;2021-08-21T16:55:53+08:00&quot;, &quot;deleted_at&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;updated_at&quot;: &quot;2021-08-25T10:14:57+08:00&quot;&#125; 当你的需求是修改这个对象并且整体提交更新的时候会发现以下问题 这个多余关联的对象不需要提交 发出请求的数据量变大 解决方法控制 JSON.stringify 序列化层级JSON.stringify(value[, replacer [, space]]) 使用JSON.stringify时传入第二个参数 replacer 可选如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。 那我们只需要通过replacer传入函数过滤掉属性值是Object即可 1234567891011JSON.stringify(message,(k,v) =&gt; &#123; // k,v分别代表传入对象的属性名和属性值 // 判断k是因为replace会传入一个 传入参数对象 的值,但是没有k, 我们直接返回即可 if(k) &#123; return v &#125; if(typeof v === &quot;object&quot;) &#123; return null &#125; return v&#125;) 参考资料 MDN Web Docs","tags":[],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/JavaScript/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/Golang/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://luanxu.me/categories/%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"Gorm","slug":"Gorm","permalink":"https://luanxu.me/tags/Gorm/"},{"name":"Gin","slug":"Gin","permalink":"https://luanxu.me/tags/Gin/"},{"name":"Full Stack","slug":"Full-Stack","permalink":"https://luanxu.me/tags/Full-Stack/"}]}